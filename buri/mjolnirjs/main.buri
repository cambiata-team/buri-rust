isDigitCharacter = (string, index) =>
    when string:getCharCode(index) is
        #some(codePoint) do
            if codePoint >= 48 and codePoint <= 57 do
                #some(codePoint - 48)
            else
                #none
        #none do
            #none

parseIntegerContinuation = (string, index, integerValueSoFar) =>
    when isDigitCharacter(string, index) is
        #some(digit) do
            parseIntegerContinuation(string, index + 1, (integerValueSoFar * 10) + digit)
        #none do
            integerValueSoFar

parseInteger = (string, index) =>
    when isDigitCharacter(string, index) is
        #some(digit) do
            #some(parseIntegerContinuation(string, index + 1, digit))
        #none do
            #none

parse = (input) =>
    when parseInteger(input, 0) is
        #some(integer) do #ok(#parserDocument({
            typeDeclarations: [],
            variableDeclarations: [#parserDeclaration({
                name: "x",
                value: #parserInteger(integer),
                isExported: #false
            })]
        }))
        #none do #error("Unable to parse input")

typeCheckInteger = (integer) => #ok(#genericInteger(integer))

typeCheckDeclaration = (declaration) =>
    when declaration.value is
        #parserInteger(integer) do when typeCheckInteger(integer) is
            #ok(genericInteger) do #ok(#genericDeclaration({
                name: declaration.name,
                value: genericInteger,
                isExported: declaration.isExported
            }))

loopTypeCheckDeclaration = (declarations, index, results) =>
    when declarations:get(index) is
        #some(declaration) do when typeCheckDeclaration(declaration) is
            #ok(result) do loopTypeCheckDeclaration(declarations, index + 1, results:append(result))
            #error(message) do #error(message)
        #none do #ok(results)

typeCheck = (parserDocument) =>
    typeCheckedTypeDeclarations = []
    typeCheckedVariableDeclarations = loopTypeCheckDeclaration(parserDocument.variableDeclarations, 0, [])
    #ok(9)

typeResolve = (input) => #ok(#concreteDocument)

writeJavaScript = (input) => "2"

@export
compile = (input) =>
    when parse(input) is
        #error(message) do #error(message)
        #ok(parsedTree) do when typeCheck(parsedTree) is
            #ok(typeCheckedTree) do when typeResolve(typeCheckedTree) is
                #ok(typeResolvedTree) do #ok(writeJavaScript(typeResolvedTree))
